snippet clog "Print"
println!("{:?}", $1);
endsnippet

snippet swc "Match"
match $1 {
	$2 => $3,
}
endsnippet

# ----------------------------------------------------------
# Testing
# 

snippet rtest "Test module"
#[cfg(test)]
mod tests {
	use super::*;

	$2
}
endsnippet

snippet test "Test"
#[test]
fn $1() {
	$2
}
endsnippet

snippet exp "Assert equal"
assert_eq!($1, $2)
endsnippet

# ----------------------------------------------------------
# Advent of Code
# 

snippet aoc "Advent of Code"
use std::time::Instant;

pub type Result<T> = std::result::Result<T, Box<dyn std::error::Error>>;

fn main() -> Result<()> {
		let input = parse_input(include_str!("../input"));

		println!("Results for Day 1");
		println!("============================");

		// Part 1
		let now = Instant::now();
		let part_01 = day_01::part_01(&input)?;

		println!("Part 1: {:?} ({:.2?})", part_01, now.elapsed());

		// Part 2
		let now = Instant::now();
		let part_02 = day_01::part_02(&input)?;

		println!("Part 2: {:?} ({:.2?})", part_02, now.elapsed());

		Ok(())
}

fn parse_input(input: &str) -> Vec<i32> {
		input
				.lines()
				.map(|l| l.trim())
				.filter(|l| !l.is_empty())
				.map(|l| l.parse::<i32>().unwrap())
				.collect::<Vec<i32>>()
}
endsnippet

snippet aoclib "Advent of Code lib"
pub type Result<T> = std::result::Result<T, Box<dyn std::error::Error>>;

pub fn part_01(_input: &Vec<i32>) -> Result<()> {
		Ok(())
}

pub fn part_02(_input: &Vec<i32>) -> Result<()> {
		Ok(())
}
endsnippet
