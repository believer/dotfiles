# Log a value to the terminal
#
# **Jump sequence:**
#
# - `$1` - What to log
snippet clog "Print"
println!("{:?}", $1);
endsnippet

# Add a pattern matching setup with one arm
#
# **Jump sequence:**
#
# - `$1` - Value to match on
# - `$2` - Matching pattern
# - `$3` - Expression
snippet swc "Match"
match $1 {
	$2 => $3,
}
endsnippet

# Add a test module. It imports the outer module using `use super::*` to
# simplify testing.
#
# **Jump sequence:**
#
# - `$1` - Test module contents
snippet rtest "Test module"
#[cfg(test)]
mod tests {
	use super::*;

	$1
}
endsnippet

# Add a test
#
# **Jump sequence:**
#
# - `$1` - Test name
# - `$2` - Test contents
snippet test "Test"
#[test]
fn ${1:test_name}() {
	$2
}
endsnippet

# Add an equals assertion
#
# **Jump sequence:**
#
# - `$1` - Assertion
# - `$2` - Expected output
snippet exp "Assert equal"
assert_eq!($1, $2)
endsnippet

snippet aoc "Advent of Code setup"
use crate::common;

// Day 1: $1

#[aoc_generator(day$2)]
pub fn input_generator(input: &str) -> Vec<u32> {
	common::input_vec(input)
}

/* Part One
*/
// Your puzzle answer was
/// \`\`\`
/// use advent_of_code_2022::day_`!p snip.rv = "0" if int(t[2]) < 10 else ""`${2:1}::*;
/// let data = include_str!("../input/2022/day$2.txt");
/// assert_eq!(solve_part_01(&input_generator(data)), 0);
/// \`\`\`
#[aoc(day$2, part1)]
pub fn solve_part_01(input: &Vec<u32>) -> u32 {
	0
}

/* Part Two
*/
// Your puzzle answer was
/// \`\`\`
/// use advent_of_code_2022::day_`!p snip.rv = "0" if int(t[2]) < 10 else ""`$2::*;
/// let data = include_str!("../input/2022/day$2.txt");
/// assert_eq!(solve_part_02(&input_generator(data)), 0);
/// \`\`\`
#[aoc(day$2, part2)]
pub fn solve_part_02(input: &Vec<u32>) -> u32 {
	0
}

#[cfg(test)]
mod tests {
	use super::*;

	#[test]
	fn sample_01() {
		let data = "test";

		assert_eq!(solve_part_01(&input_generator(data)), 0)
	}
}

endsnippet

snippet aocgen "Advent of Code generator"
#[aoc_generator(day$1)]
pub fn input_generator(input: &str) -> Vec<$2> {
	
}
endsnippet
